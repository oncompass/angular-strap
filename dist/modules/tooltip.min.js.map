{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","templateUrl","template","titleTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$tooltip","$bsCompiler","compile","options","split","scope","clearTimeout","hideTimeout","$element","on","onShow","leave","hoverState","hide","leaveAnimateCallback","$emit","prefixEvent","destroyTipElement","onHide","_tipToHide","evt","preventDefault","element","triggers","nodeName","isTouch","toggle","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","getBoundingClientRect","rect","p","width","height","top","left","extend","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","timeout","$isShown","tipScope","$destroy","$$phase","$options","config","$promise","$scope","$new","$rootScope","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","isDefined","onBeforeShow","after","parent","lastChild","isFunction","display","visibility","link","clonedElement","animation","addClass","prefixClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","enterAnimateCallback","then","handlePopoversElementHoverActions","setTimeout","_blur","blur","onBeforeHide","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","clientHeight","originalPlacement","viewportPosition","footerAdjustment","bottom","replace","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","forEach","directive","$root","$digest","restrict","query","querySelectorAll","isNative","isString","tooltip","transclusion","falseValueRegExp","key","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on"],"mappings":"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","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hideTimeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n          handlePopoversElementHoverActions();\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        function handlePopoversElementHoverActions () {\n          $tooltip.$element.on('mouseenter', function () {\n            clearTimeout(hideTimeout);\n            $tooltip.$element.on('mouseleave', $tooltip.leave);\n          });\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          clearTimeout(hideTimeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          hideTimeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n              if ($tooltip.$element) {\n                $tooltip.$element.off('mouseenter');\n              }\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n          var clientWidth = document.documentElement.clientWidth;\n          var clientHeight = document.documentElement.clientHeight;\n          var footerAdjustment = 50;\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom-left/.test(originalPlacement)) {\n              if (elementPosition.right + tipWidth > clientWidth) {\n                placement = placement.replace('bottom-left', 'bottom-right');\n\n                if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                  placement = placement.replace('bottom', 'top');\n                }\n              } else if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                placement = placement.replace('bottom-left', 'top-left');\n\n                if (elementPosition.right + tipWidth > clientWidth) {\n                  placement = placement.replace('left', 'right');\n                }\n              }\n            } else {\n              if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n                placement = originalPlacement.replace('bottom', 'top');\n              } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n                placement = originalPlacement.replace('top', 'bottom');\n              }\n              if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n                placement = placement.replace('left', 'right');\n              } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n                placement = placement.replace('right', 'left');\n              }\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}