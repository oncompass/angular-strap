{"version":3,"sources":["angular-strap.js","tooltip/tooltip.js","helpers/compiler.js","aside/aside.js","typeahead/typeahead.js","scrollspy/scrollspy.js","timepicker/timepicker.js","select/select.js","tab/tab.js","popover/popover.js","navbar/navbar.js","button/button.js","modal/modal.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","dropdown/dropdown.js","datepicker/datepicker.js","collapse/collapse.js","alert/alert.js","affix/affix.js","module.js"],"names":["prefixClass","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","data","this","compile","controller","console","controllerAs","resolve","locals","bindToController","angular","forEach","value","isString","$injector","key","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","bsCompilerService","$inject","target","provider","placement","titleTemplate","trigger","keyboard","show","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$tooltip","$bsCompiler","split","clearTimeout","hideTimeout","$element","on","onShow","leave","hoverState","hide","leaveAnimateCallback","$emit","prefixEvent","destroyTipElement","onHide","_tipToHide","evt","preventDefault","triggers","nodeName","isTouch","toggle","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","timeout","$isShown","tipScope","$destroy","$$phase","$options","config","$promise","$scope","$new","$rootScope","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","isDefined","onBeforeShow","after","parent","lastChild","isFunction","display","visibility","clonedElement","addClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","enterAnimateCallback","handlePopoversElementHoverActions","setTimeout","_blur","blur","onBeforeHide","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","clientHeight","originalPlacement","viewportPosition","footerAdjustment","bottom","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","directive","$root","$digest","restrict","query","querySelectorAll","isNative","tooltip","transclusion","falseValueRegExp","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on","minLength","filter","limit","autoSelect","comparator","trimValue","$typeahead","parentScope","$resetMatches","$window","$matches","activate","$activeIndex","select","index","$select","matches","$isVisible","update","$render","onSelect","$setViewValue","equals","$onMouseDown","clientTop","active","offsetTop","clientBottom","highWatermark","Math","lowWatermark","keyCode","$$updateScrollTop","isUndefined","$onKeyDown","TypeaheadFactory","array","$filter","expression","results","postLink","require","charAt","toUpperCase","bsOptions","parsedOptions","$parseOptions","typeahead","watchedOptions","$watchCollection","values","watchOptions","$match","ngModel","$modelValue","valuesFn","selectMode","$viewValue","substring","displayValue","$formatters","push","modelValue","selected","ss","selectionStart","val","selectionEnd","setSelectionRange","sd","label","spies","$document","windowEl","debounce","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","activeElement","source","$getTrackedElement","removeClass","targetElement","querySelector","trackedElement","b","trackElement","toDelete","untrackElement","splice","scrollspy","childEl","child","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","collapse","moveStart","moveEnd","focusElement","_init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","timeSeparator","minute","minutesFormat","secondsFormat","showSeconds","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","$isBuilt","keep","Date","setHours","setMinutes","setSeconds","copy","midIndex","hours","disabled","minutes","$date","seconds","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","timezoneOffsetAdjust","NaN","parse","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","$isActive","$selectNone","$updateActiveIndex","a","indexOf","$apply","isArray","$getIndex","anchor","anchorCandidate","$selectScrollFix","$isIE","stopImmediatePropagation","ua","tagName","e","dataMultiple","inputEl","addEventListener","join","$isEmpty","_tabsHash","_addTabControl","navClass","activeClass","$attrs","control","$activeClass","self","$panes","$activePaneChangeListeners","$push","pane","$active","$navClass","$remove","activeIndex","$setActive","name","fn","$pane","$onKeyPress","$index","$tab","transclude","ngModelCtrl","bsTabsCtrl","tabKey","addTabControl","controllers","attrs","bsActivePane","parsedBsActivePane","assign","$parse","render","customClass","content","$popover","PopoverFactory","requestAnimationFrame","bsPopover","popover","routeAttr","$navbar","liElements","li","liElement","pattern","path","RegExp","regexp","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","isActive","checked","toggleClass","bind","toggleEvent","hasClass","v","backdrop","size","zIndex","bodyElement","backdropCount","dialogBaseZindex","validSizes","ModalFactory","$modal","unbindBackdropEvents","modalElement","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","backdropBaseZindex","$show","destroyModalElement","z-index","defaultPrevented","minor","backdropAnimation","bindBackdropEvents","which","lg","sm","modalClass","bsModal","modal","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$values","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","factory","offsetParent","docElement","ownerDocument","outer","window","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","call","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","$localeProvider","milliseconds","ParseDate","prototype","noop","indexOfCaseInsensitive","len","str","toString","strict","DateParserFactory","day","month","getFullYear","getMonth","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","text","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDate","today","getDateForAttribute","substr","getTimeForAttribute","daylightSavingAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","service","AsideFactory","$aside","bsAside","aside","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","parentEl","tAttrs","nextSibling","nodeType","parentNode","removeChild","dropdown","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$hasToday","$picker","$selectPane","$views","$mode","$toggleMode","$setToday","$clear","setMode","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","$updateSelected","built","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","onKeyDown","datepickerViews","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","arrays","mod","n","arr","weekDaysMin","weekDaysLabelsHtml","picker","weekDaysLabels","concat","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","build","days","isToday","toDateString","muted","showLabels","labels","isTodayDisabled","isSelected","getDay","months","lastDate","actualMonth","firstYear","years","actualYear","Array","setYear","startCollapsed","allowMultiple","activeIndexes","$targets","activeItems","activateItem","$collapse","$viewChangeListeners","$registerToggle","$toggles","$unregisterToggle","$unregisterTarget","deactivateItem","fixActiveItemIndexes","disallowToggle","$activeIndexes","bsCollapseCtrl","actionEventHandler","bsCollapseToggle","$registerTarget","action","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","inlineStyles","$affix","setWidth","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","pageYOffset","offsetBottom","elementHeight","initialAffixTop","affixed","unpin","$parseOffsets","affix","offsetUnpin","$onResize","initialTop","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hideTimeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n          handlePopoversElementHoverActions();\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        function handlePopoversElementHoverActions () {\n          $tooltip.$element.on('mouseenter', function () {\n            clearTimeout(hideTimeout);\n            $tooltip.$element.on('mouseleave', $tooltip.leave);\n          });\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          clearTimeout(hideTimeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          hideTimeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n              if ($tooltip.$element) {\n                $tooltip.$element.off('mouseenter');\n              }\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n          var clientWidth = document.documentElement.clientWidth;\n          var clientHeight = document.documentElement.clientHeight;\n          var footerAdjustment = 50;\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom-left/.test(originalPlacement)) {\n              if (elementPosition.right + tipWidth > clientWidth) {\n                placement = placement.replace('bottom-left', 'bottom-right');\n\n                if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                  placement = placement.replace('bottom', 'top');\n                }\n              } else if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                placement = placement.replace('bottom-left', 'top-left');\n\n                if (elementPosition.right + tipWidth > clientWidth) {\n                  placement = placement.replace('left', 'right');\n                }\n              }\n            } else {\n              if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n                placement = originalPlacement.replace('bottom', 'top');\n              } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n                placement = originalPlacement.replace('top', 'bottom');\n              }\n              if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n                placement = placement.replace('left', 'right');\n              } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n                placement = placement.replace('right', 'left');\n              }\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: typeahead/typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory (element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $typeahead);\n          }\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$$updateScrollTop = function (container, index) {\n          if (index > -1 && index < container.children.length) {\n            var active = container.children[index];\n            var clientTop = active.offsetTop;\n            var clientBottom = active.offsetTop + active.clientHeight;\n            var highWatermark = container.scrollTop;\n            var lowWatermark = container.scrollTop + container.clientHeight;\n\n            // active entry overlaps top border\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\n            } else if (clientBottom > lowWatermark) {\n              // top of active element is invisible because it's below the bottom of the visible container window\n              container.scrollTop = clientTop;\n            }\n          }\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          // Navigate with keyboard\n          } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {\n            scope.$activeIndex--;\n          } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {\n            scope.$activeIndex++;\n          } else if (angular.isUndefined(scope.$activeIndex)) {\n            scope.$activeIndex = 0;\n          }\n\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Fixes firefox bug when using objects in model with typeahead\n        // Yes this breaks any other directive using a 'change' event on this input,\n        // but if it is using the 'change' event why is it used with typeahead?\n        element.off('change');\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) {\n          bsOptions += ' | ' + filter + ':$viewValue';\n          if (comparator) bsOptions += ':' + comparator;\n        }\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          var ss = element[0].selectionStart;\n          var sd = element[0].selectionEnd;\n          element.val(options.trimValue === false ? value : value.trim());\n          element[0].setSelectionRange(ss, sd);\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: scrollspy/scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName (element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory (config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink (scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink (element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      defaultDate: 'auto',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory (element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes (time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n          }\n\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection (start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime (parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok',\n      toggle: false\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory (element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              if (options.toggle) {\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\n              } else {\n                controller.$setViewValue(value);\n              }\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $select);\n          }\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            var anchor;\n\n            if (evt.target.nodeName !== 'A') {\n              var anchorCandidate = targetEl.parent();\n              while (!anchor && anchorCandidate.length > 0) {\n                if (anchorCandidate[0].nodeName === 'A') {\n                  anchor = anchorCandidate;\n                }\n                anchorCandidate = anchorCandidate.parent();\n              }\n            }\n\n            if (anchor) {\n              angular.element(anchor).triggerHandler('click');\n            } else {\n              targetEl.triggerHandler('click');\n            }\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n    var _tabsHash = {};\n\n    var _addTabControl = function (key, control) {\n      if (!_tabsHash[key]) _tabsHash[key] = control;\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n      self.$onKeyPress = $scope.$onKeyPress = function (e, index) {\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\n          self.$setActive(index);\n        }\n      };\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      $tab.addTabControl = _addTabControl;\n      $tab.tabsHash = _tabsHash;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink (scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\n        // tabs are available in the tab component\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\n        }\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render () {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory (element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\n            if (newValue === false) {\n              popover.setEnabled(false);\n            } else {\n              popover.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: navbar/navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: button/button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink (element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = !!controller.$viewValue;\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink (element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\n            value = scope.$eval(v);\n          } else {\n            value = v;\n          }\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$viewValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true,\n      size: null,\n      zIndex: null\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      var validSizes = {\n        lg: 'modal-lg',\n        sm: 'modal-sm'\n      };\n\n      function ModalFactory (config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        if (options.zIndex) {\n          dialogBaseZindex = parseInt(options.zIndex, 10);\n          backdropBaseZindex = dialogBaseZindex - 10;\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($modal);\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: size\n          if (options.size && validSizes[options.size]) {\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($modal);\n          }\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($modal);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            // decrement number of backdrops\n            backdropCount--;\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($modal);\n          }\n          if (findElement('.modal').length <= 0) {\n            bodyElement.removeClass(options.prefixClass + '-open');\n          }\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents () {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents () {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick (evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault (evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement () {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: helpers/raf.js\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: aside/aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory (config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory (element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (/(9)/.test(evt.keyCode)) {\n            $dropdown.hide();\n            return;\n          }\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick (evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink (scope, element, attr) {\n\n          // Directive options\n          var options = {\n            scope: scope\n          };\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // bind functions from the attrs to the show and hide events\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n            if (angular.isDefined(attr[bsKey])) {\n              options[key] = scope.$eval(attr[bsKey]);\n            }\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      hasToday: false,\n      hasClear: false,\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory (element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        scope.$hasToday = options.hasToday;\n        scope.$hasClear = options.hasClear;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date, disabled) {\n          if (disabled) return;\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n        scope.$setToday = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(new Date());\n          } else {\n            $datepicker.select(new Date(), true);\n          }\n        };\n        scope.$clear = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(null);\n          } else {\n            $datepicker.select(null, true);\n          }\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (angular.isDate(date)) {\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n              controller.$dateValue = new Date(date);\n            }\n          } else {\n            controller.$dateValue = null;\n          }\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected (el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges (ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate (parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          // do not adjust date if timezone is UTC\n          if (options.timezone === 'UTC') {\n            controller.$dateValue = date;\n          } else {\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          }\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split (arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod (n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            scope.isTodayDisabled = this.isDisabled(new Date());\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n            else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n            else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n            else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: collapse/collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes (index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive (value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) !== -1;\n      }\n\n      function deactivateItem (value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem (value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink (scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        var actionEventHandler = function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        };\n\n        element.on('click', actionEventHandler);\n        element.bind('keydown keypress', function (e) {\n          if (e.which === 13) {\n            actionEventHandler();\n            e.preventDefault();\n          } else if (e.which !== 16 && e.which !== 9) {\n            e.preventDefault();\n          }\n        });\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render () {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory (config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: affix/affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true,\n      setWidth: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory (element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = options.setWidth && !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element[0].style.position;\n          var initialTop = element[0].style.top;\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n            element.css('top', '');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n            element.css('top', initialTop);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null) {\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop () {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight () {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window, $timeout) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink (scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix;\n        $timeout(function () { affix = $affix(element, options); });\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hideTimeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n          handlePopoversElementHoverActions();\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        function handlePopoversElementHoverActions () {\n          $tooltip.$element.on('mouseenter', function () {\n            clearTimeout(hideTimeout);\n            $tooltip.$element.on('mouseleave', $tooltip.leave);\n          });\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          clearTimeout(hideTimeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          hideTimeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n              if ($tooltip.$element) {\n                $tooltip.$element.off('mouseenter');\n              }\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n          var clientWidth = document.documentElement.clientWidth;\n          var clientHeight = document.documentElement.clientHeight;\n          var footerAdjustment = 50;\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom-left/.test(originalPlacement)) {\n              if (elementPosition.right + tipWidth > clientWidth) {\n                placement = placement.replace('bottom-left', 'bottom-right');\n\n                if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                  placement = placement.replace('bottom', 'top');\n                }\n              } else if (elementPosition.bottom + tipHeight + footerAdjustment > clientHeight) {\n                placement = placement.replace('bottom-left', 'top-left');\n\n                if (elementPosition.right + tipWidth > clientWidth) {\n                  placement = placement.replace('left', 'right');\n                }\n              }\n            } else {\n              if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n                placement = originalPlacement.replace('bottom', 'top');\n              } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n                placement = originalPlacement.replace('top', 'bottom');\n              }\n              if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n                placement = placement.replace('left', 'right');\n              } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n                placement = placement.replace('right', 'left');\n              }\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory (config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory (element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $typeahead);\n          }\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$$updateScrollTop = function (container, index) {\n          if (index > -1 && index < container.children.length) {\n            var active = container.children[index];\n            var clientTop = active.offsetTop;\n            var clientBottom = active.offsetTop + active.clientHeight;\n            var highWatermark = container.scrollTop;\n            var lowWatermark = container.scrollTop + container.clientHeight;\n\n            // active entry overlaps top border\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\n            } else if (clientBottom > lowWatermark) {\n              // top of active element is invisible because it's below the bottom of the visible container window\n              container.scrollTop = clientTop;\n            }\n          }\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          // Navigate with keyboard\n          } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {\n            scope.$activeIndex--;\n          } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {\n            scope.$activeIndex++;\n          } else if (angular.isUndefined(scope.$activeIndex)) {\n            scope.$activeIndex = 0;\n          }\n\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Fixes firefox bug when using objects in model with typeahead\n        // Yes this breaks any other directive using a 'change' event on this input,\n        // but if it is using the 'change' event why is it used with typeahead?\n        element.off('change');\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) {\n          bsOptions += ' | ' + filter + ':$viewValue';\n          if (comparator) bsOptions += ':' + comparator;\n        }\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          var ss = element[0].selectionStart;\n          var sd = element[0].selectionEnd;\n          element.val(options.trimValue === false ? value : value.trim());\n          element[0].setSelectionRange(ss, sd);\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName (element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory (config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink (scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink (element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      defaultDate: 'auto',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory (element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes (time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n          }\n\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection (start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime (parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok',\n      toggle: false\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory (element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              if (options.toggle) {\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\n              } else {\n                controller.$setViewValue(value);\n              }\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $select);\n          }\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            var anchor;\n\n            if (evt.target.nodeName !== 'A') {\n              var anchorCandidate = targetEl.parent();\n              while (!anchor && anchorCandidate.length > 0) {\n                if (anchorCandidate[0].nodeName === 'A') {\n                  anchor = anchorCandidate;\n                }\n                anchorCandidate = anchorCandidate.parent();\n              }\n            }\n\n            if (anchor) {\n              angular.element(anchor).triggerHandler('click');\n            } else {\n              targetEl.triggerHandler('click');\n            }\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n    var _tabsHash = {};\n\n    var _addTabControl = function (key, control) {\n      if (!_tabsHash[key]) _tabsHash[key] = control;\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n      self.$onKeyPress = $scope.$onKeyPress = function (e, index) {\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\n          self.$setActive(index);\n        }\n      };\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      $tab.addTabControl = _addTabControl;\n      $tab.tabsHash = _tabsHash;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink (scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\n        // tabs are available in the tab component\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\n        }\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render () {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory (element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\n            if (newValue === false) {\n              popover.setEnabled(false);\n            } else {\n              popover.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink (element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = !!controller.$viewValue;\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink (element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\n            value = scope.$eval(v);\n          } else {\n            value = v;\n          }\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$viewValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true,\n      size: null,\n      zIndex: null\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      var validSizes = {\n        lg: 'modal-lg',\n        sm: 'modal-sm'\n      };\n\n      function ModalFactory (config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        if (options.zIndex) {\n          dialogBaseZindex = parseInt(options.zIndex, 10);\n          backdropBaseZindex = dialogBaseZindex - 10;\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($modal);\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: size\n          if (options.size && validSizes[options.size]) {\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($modal);\n          }\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($modal);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            // decrement number of backdrops\n            backdropCount--;\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($modal);\n          }\n          if (findElement('.modal').length <= 0) {\n            bodyElement.removeClass(options.prefixClass + '-open');\n          }\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents () {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents () {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick (evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault (evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement () {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory (element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (/(9)/.test(evt.keyCode)) {\n            $dropdown.hide();\n            return;\n          }\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick (evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink (scope, element, attr) {\n\n          // Directive options\n          var options = {\n            scope: scope\n          };\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // bind functions from the attrs to the show and hide events\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n            if (angular.isDefined(attr[bsKey])) {\n              options[key] = scope.$eval(attr[bsKey]);\n            }\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      hasToday: false,\n      hasClear: false,\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory (element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        scope.$hasToday = options.hasToday;\n        scope.$hasClear = options.hasClear;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date, disabled) {\n          if (disabled) return;\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n        scope.$setToday = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(new Date());\n          } else {\n            $datepicker.select(new Date(), true);\n          }\n        };\n        scope.$clear = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(null);\n          } else {\n            $datepicker.select(null, true);\n          }\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (angular.isDate(date)) {\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n              controller.$dateValue = new Date(date);\n            }\n          } else {\n            controller.$dateValue = null;\n          }\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected (el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges (ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate (parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          // do not adjust date if timezone is UTC\n          if (options.timezone === 'UTC') {\n            controller.$dateValue = date;\n          } else {\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          }\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split (arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod (n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            scope.isTodayDisabled = this.isDisabled(new Date());\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n            else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n            else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n            else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes (index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive (value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) !== -1;\n      }\n\n      function deactivateItem (value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem (value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink (scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        var actionEventHandler = function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        };\n\n        element.on('click', actionEventHandler);\n        element.bind('keydown keypress', function (e) {\n          if (e.which === 13) {\n            actionEventHandler();\n            e.preventDefault();\n          } else if (e.which !== 16 && e.which !== 9) {\n            e.preventDefault();\n          }\n        });\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink (scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render () {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory (config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true,\n      setWidth: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory (element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = options.setWidth && !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element[0].style.position;\n          var initialTop = element[0].style.top;\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n            element.css('top', '');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n            element.css('top', initialTop);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null) {\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop () {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight () {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window, $timeout) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink (scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix;\n        $timeout(function () { affix = $affix(element, options); });\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n"],"sourceRoot":"/source/"}